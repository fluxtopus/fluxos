"""
# REVIEW:
# - ExecutionNode and snapshots are mutable and shared across async contexts; no concurrency/locking contract defined.
# - Interface exposes subscribe_to_updates callbacks without specifying threading/async context; implementations may vary.
Execution Tree Data Structures for Sub-Agent Workflow Tracking

This module defines the core data structures for tracking and visualizing
the execution flow of sub-agents in a hierarchical tree structure.
"""

from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional, Set, Callable
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import uuid
import asyncio
from collections import defaultdict


class NodeType(Enum):
    """Types of execution nodes"""
    ROOT = "root"                    # Root workflow node
    AGENT = "agent"                 # Individual agent execution
    SUB_AGENT = "sub_agent"         # Sub-agent generated by parent
    PARALLEL_GROUP = "parallel"     # Parallel execution group
    SEQUENTIAL_GROUP = "sequential" # Sequential execution group
    CONDITIONAL = "conditional"     # Conditional execution node
    LOOP = "loop"                   # Loop execution node


class ExecutionStatus(Enum):
    """Execution status of nodes"""
    PENDING = "pending"
    RUNNING = "running"
    PAUSED = "paused"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"
    TIMEOUT = "timeout"
    WAITING = "waiting"
    EXPANDED = "expanded"  # Runtime for_each template node that was expanded


class ExecutionPriority(Enum):
    """Execution priority levels"""
    LOW = 1
    NORMAL = 2
    HIGH = 3
    CRITICAL = 4


@dataclass
class ExecutionMetrics:
    """Metrics for execution node performance"""
    
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    duration: Optional[timedelta] = None
    cpu_usage_percent: float = 0.0
    memory_usage_mb: float = 0.0
    peak_memory_mb: float = 0.0
    operations_count: int = 0
    errors_count: int = 0
    warnings_count: int = 0
    
    def calculate_duration(self) -> None:
        """Calculate duration if start and end times are set"""
        if self.start_time and self.end_time:
            self.duration = self.end_time - self.start_time
    
    def update_peak_memory(self, current_memory: float) -> None:
        """Update peak memory usage"""
        self.memory_usage_mb = current_memory
        if current_memory > self.peak_memory_mb:
            self.peak_memory_mb = current_memory


@dataclass
class ExecutionNode:
    """
    Represents a single node in the execution tree
    Contains execution state, metrics, and relationships
    """
    
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = ""
    node_type: NodeType = NodeType.AGENT
    status: ExecutionStatus = ExecutionStatus.PENDING
    priority: ExecutionPriority = ExecutionPriority.NORMAL
    
    # Relationships
    parent_id: Optional[str] = None
    children_ids: Set[str] = field(default_factory=set)
    dependencies: Set[str] = field(default_factory=set)
    
    # Execution data
    agent_id: Optional[str] = None
    context_id: Optional[str] = None
    task_data: Dict[str, Any] = field(default_factory=dict)
    result_data: Dict[str, Any] = field(default_factory=dict)
    error_data: Optional[Dict[str, Any]] = None
    
    # Timing and constraints
    created_at: datetime = field(default_factory=datetime.utcnow)
    scheduled_at: Optional[datetime] = None
    timeout_seconds: Optional[int] = None
    retry_count: int = 0
    max_retries: int = 0
    
    # Metrics and monitoring
    metrics: ExecutionMetrics = field(default_factory=ExecutionMetrics)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    # Execution configuration
    parallel_execution: bool = False
    conditional_expression: Optional[str] = None
    loop_condition: Optional[str] = None
    
    def __post_init__(self):
        """Validate node after creation"""
        if not self.name:
            self.name = f"{self.node_type.value}_{self.id[:8]}"
    
    def add_child(self, child_id: str) -> None:
        """Add a child node ID"""
        self.children_ids.add(child_id)
    
    def remove_child(self, child_id: str) -> None:
        """Remove a child node ID"""
        self.children_ids.discard(child_id)
    
    def add_dependency(self, dependency_id: str) -> None:
        """Add a dependency node ID"""
        self.dependencies.add(dependency_id)
    
    def is_ready_to_execute(self, completed_nodes: Set[str]) -> bool:
        """Check if all dependencies are completed"""
        return self.dependencies.issubset(completed_nodes)
    
    def start_execution(self) -> None:
        """Mark node as started and update metrics"""
        self.status = ExecutionStatus.RUNNING
        self.metrics.start_time = datetime.utcnow()
    
    def complete_execution(self, result_data: Optional[Dict[str, Any]] = None) -> None:
        """Mark node as completed and update metrics"""
        self.status = ExecutionStatus.COMPLETED
        self.metrics.end_time = datetime.utcnow()
        self.metrics.calculate_duration()
        if result_data:
            self.result_data = result_data
    
    def fail_execution(self, error_data: Dict[str, Any]) -> None:
        """Mark node as failed and store error data"""
        self.status = ExecutionStatus.FAILED
        self.metrics.end_time = datetime.utcnow()
        self.metrics.calculate_duration()
        self.error_data = error_data
        self.metrics.errors_count += 1
    
    def should_retry(self) -> bool:
        """Check if node should be retried"""
        return (self.status == ExecutionStatus.FAILED and 
                self.retry_count < self.max_retries)
    
    def retry_execution(self) -> None:
        """Reset node for retry"""
        if self.should_retry():
            self.retry_count += 1
            self.status = ExecutionStatus.PENDING
            self.error_data = None
            self.metrics = ExecutionMetrics()


@dataclass
class ExecutionTreeSnapshot:
    """Immutable snapshot of execution tree state"""
    
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    tree_id: str = ""
    timestamp: datetime = field(default_factory=datetime.utcnow)
    nodes: Dict[str, ExecutionNode] = field(default_factory=dict)
    root_node_id: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def get_node_count_by_status(self) -> Dict[ExecutionStatus, int]:
        """Get count of nodes by status"""
        counts = defaultdict(int)
        for node in self.nodes.values():
            counts[node.status] += 1
        return dict(counts)
    
    def get_execution_summary(self) -> Dict[str, Any]:
        """Get summary of execution tree state"""
        status_counts = self.get_node_count_by_status()
        total_nodes = len(self.nodes)
        
        return {
            "tree_id": self.tree_id,
            "timestamp": self.timestamp,
            "total_nodes": total_nodes,
            "status_counts": status_counts,
            "completion_rate": status_counts.get(ExecutionStatus.COMPLETED, 0) / total_nodes if total_nodes > 0 else 0,
            "failure_rate": status_counts.get(ExecutionStatus.FAILED, 0) / total_nodes if total_nodes > 0 else 0,
            "active_nodes": status_counts.get(ExecutionStatus.RUNNING, 0)
        }


class ExecutionTreeInterface(ABC):
    """
    Abstract interface for execution tree operations
    Follows SRP - handles only tree structure and tracking operations
    """
    
    @abstractmethod
    async def create_tree(self, root_name: str, metadata: Optional[Dict[str, Any]] = None) -> str:
        """
        Create a new execution tree
        
        Args:
            root_name: Name for the root node
            metadata: Optional metadata for the tree
            
        Returns:
            str: The created tree ID
        """
        pass
    
    @abstractmethod
    async def add_node(
        self, 
        tree_id: str, 
        node: ExecutionNode, 
        parent_id: Optional[str] = None
    ) -> bool:
        """
        Add a node to the execution tree
        
        Args:
            tree_id: The tree identifier
            node: The execution node to add
            parent_id: Optional parent node ID
            
        Returns:
            bool: True if node added successfully, False otherwise
        """
        pass
    
    @abstractmethod
    async def update_node_status(
        self, 
        tree_id: str, 
        node_id: str, 
        status: ExecutionStatus,
        result_data: Optional[Dict[str, Any]] = None,
        error_data: Optional[Dict[str, Any]] = None
    ) -> bool:
        """
        Update the status of a node
        
        Args:
            tree_id: The tree identifier
            node_id: The node identifier
            status: New execution status
            result_data: Optional result data for completed nodes
            error_data: Optional error data for failed nodes
            
        Returns:
            bool: True if update successful, False otherwise
        """
        pass
    
    @abstractmethod
    async def get_node(self, tree_id: str, node_id: str) -> Optional[ExecutionNode]:
        """
        Get a specific node from the tree
        
        Args:
            tree_id: The tree identifier
            node_id: The node identifier
            
        Returns:
            Optional[ExecutionNode]: The node or None if not found
        """
        pass
    
    @abstractmethod
    async def get_tree_snapshot(self, tree_id: str) -> Optional[ExecutionTreeSnapshot]:
        """
        Get a snapshot of the entire execution tree
        
        Args:
            tree_id: The tree identifier
            
        Returns:
            Optional[ExecutionTreeSnapshot]: Tree snapshot or None if not found
        """
        pass
    
    @abstractmethod
    async def get_children(self, tree_id: str, parent_id: str) -> List[ExecutionNode]:
        """
        Get all child nodes of a parent
        
        Args:
            tree_id: The tree identifier
            parent_id: The parent node identifier
            
        Returns:
            List[ExecutionNode]: List of child nodes
        """
        pass
    
    @abstractmethod
    async def get_ready_nodes(self, tree_id: str) -> List[ExecutionNode]:
        """
        Get all nodes that are ready for execution (dependencies satisfied)
        
        Args:
            tree_id: The tree identifier
            
        Returns:
            List[ExecutionNode]: List of ready nodes
        """
        pass
    
    @abstractmethod
    async def subscribe_to_updates(
        self, 
        tree_id: str, 
        callback: Callable[[ExecutionNode], None]
    ) -> str:
        """
        Subscribe to real-time updates for a tree
        
        Args:
            tree_id: The tree identifier
            callback: Callback function for node updates
            
        Returns:
            str: Subscription ID
        """
        pass
    
    @abstractmethod
    async def unsubscribe_from_updates(self, subscription_id: str) -> bool:
        """
        Unsubscribe from tree updates
        
        Args:
            subscription_id: The subscription identifier
            
        Returns:
            bool: True if unsubscription successful, False otherwise
        """
        pass
    
    @abstractmethod
    async def delete_tree(self, tree_id: str) -> bool:
        """
        Delete an execution tree and all its nodes
        
        Args:
            tree_id: The tree identifier
            
        Returns:
            bool: True if deletion successful, False otherwise
        """
        pass
    
    @abstractmethod
    async def get_execution_path(self, tree_id: str, node_id: str) -> List[ExecutionNode]:
        """
        Get the execution path from root to a specific node
        
        Args:
            tree_id: The tree identifier
            node_id: The target node identifier
            
        Returns:
            List[ExecutionNode]: List of nodes in execution path
        """
        pass
    
    @abstractmethod
    async def get_tree_metrics(self, tree_id: str) -> Dict[str, Any]:
        """
        Get aggregated metrics for the entire tree
        
        Args:
            tree_id: The tree identifier
            
        Returns:
            Dict[str, Any]: Tree execution metrics
        """
        pass


class ExecutionTreeException(Exception):
    """Base exception for execution tree operations"""
    pass


class TreeNotFoundError(ExecutionTreeException):
    """Raised when requested tree is not found"""
    pass


class NodeNotFoundError(ExecutionTreeException):
    """Raised when requested node is not found"""
    pass


class CircularDependencyError(ExecutionTreeException):
    """Raised when circular dependency is detected"""
    pass


class InvalidTreeStructureError(ExecutionTreeException):
    """Raised when tree structure is invalid"""
    pass
