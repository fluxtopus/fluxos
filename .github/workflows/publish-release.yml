name: Publish Release

on:
  push:
    branches:
      - main
    paths:
      - manifest.yaml
      - release/latest-release-plan.json
  workflow_dispatch:

concurrency:
  group: publish-release-main
  cancel-in-progress: false

jobs:
  publish:
    runs-on: ubuntu-latest
    environment: release
    permissions:
      contents: write
      packages: write
      id-token: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install release dependencies
        shell: bash
        run: |
          python3 -m pip install --upgrade pip
          python3 -m pip install pyyaml
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Read release plan metadata
        id: plan
        shell: bash
        run: |
          python3 - <<'PY' >> "$GITHUB_OUTPUT"
          import json
          from pathlib import Path

          import yaml

          plan_file = Path('release/latest-release-plan.json')
          if not plan_file.exists():
              print('has_changes=false')
              print('has_apps=false')
              print('has_python_packages=false')
              print('has_typescript_packages=false')
              print('app_images_json=[]')
              print('python_package_dirs=')
              print('platform_release=')
              raise SystemExit(0)

          plan = json.loads(plan_file.read_text(encoding='utf-8'))
          components = yaml.safe_load(Path('release/components.yaml').read_text(encoding='utf-8'))['components']
          manifest = yaml.safe_load(Path('manifest.yaml').read_text(encoding='utf-8'))
          by_name = {c['name']: c for c in components}
          manifest_components = manifest.get('components', {})

          changed = [c['name'] for c in plan.get('components', [])]
          python_dirs = []
          app_images = []
          has_ts_pkg = False
          for name in changed:
              comp = by_name[name]
              kind = comp.get('kind')

              if kind == 'python-package':
                  python_dirs.append(Path(comp['publish_dir']).name)
              if kind == 'typescript-package':
                  has_ts_pkg = True
              if kind == 'app':
                  manifest_component = manifest_components.get(name, {})
                  artifact = manifest_component.get('artifact', {})
                  image_repository = artifact.get('image_repository') or comp.get('image_repository')
                  dockerfile = artifact.get('dockerfile') or comp.get('dockerfile')
                  version = manifest_component.get('version')
                  missing = []
                  if not image_repository:
                      missing.append('image_repository')
                  if not dockerfile:
                      missing.append('dockerfile')
                  if not version:
                      missing.append('version')
                  if missing:
                      raise SystemExit(
                          f"Missing app publish metadata for {name}: {', '.join(missing)}"
                      )
                  app_images.append(
                      {
                          'name': name,
                          'image_repository': image_repository,
                          'dockerfile': dockerfile,
                          'version': version,
                      }
                  )

          print(f"has_changes={'true' if changed else 'false'}")
          print(f"has_apps={'true' if app_images else 'false'}")
          print(f"has_python_packages={'true' if python_dirs else 'false'}")
          print(f"has_typescript_packages={'true' if has_ts_pkg else 'false'}")
          print(f"python_package_dirs={','.join(python_dirs)}")
          print(f"platform_release={manifest.get('platform_release', '')}")
          print("app_images_json<<EOF")
          print(json.dumps(app_images))
          print("EOF")
          PY

      - name: Stop when no release plan components exist
        if: steps.plan.outputs.has_changes != 'true'
        shell: bash
        run: |
          echo "No components in release/latest-release-plan.json; skipping publish."
          exit 0

      - name: Build changed Python packages
        if: steps.plan.outputs.has_python_packages == 'true'
        shell: bash
        run: |
          IFS=',' read -r -a pkgs <<< "${{ steps.plan.outputs.python_package_dirs }}"
          args=()
          for pkg in "${pkgs[@]}"; do
            [[ -z "$pkg" ]] && continue
            args+=(--package "$pkg")
          done
          ./scripts/publish-python-packages.sh --build-only "${args[@]}"

      - name: Build changed TypeScript package
        if: steps.plan.outputs.has_typescript_packages == 'true'
        shell: bash
        run: |
          cd packages/mimic-sdk-ts
          npm ci
          npm run build

      - name: Set up Docker Buildx
        if: steps.plan.outputs.has_apps == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        if: steps.plan.outputs.has_apps == 'true'
        shell: bash
        env:
          GHCR_TOKEN: ${{ github.token }}
        run: |
          echo "${GHCR_TOKEN}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin

      - name: Publish changed app images
        if: steps.plan.outputs.has_apps == 'true'
        shell: bash
        env:
          APP_IMAGES_JSON: ${{ steps.plan.outputs.app_images_json }}
          PLATFORM_RELEASE: ${{ steps.plan.outputs.platform_release }}
          GIT_SHA: ${{ github.sha }}
        run: |
          python3 - <<'PY'
          import json
          import os
          import subprocess

          app_images = json.loads(os.environ["APP_IMAGES_JSON"])
          platform_release = os.environ["PLATFORM_RELEASE"]
          short_sha = os.environ["GIT_SHA"][:12]
          if not platform_release:
              raise SystemExit("platform_release is required to tag published app images")

          for app in app_images:
              repository = app["image_repository"]
              version = app["version"]
              dockerfile = app["dockerfile"]
              tags = [
                  f"{repository}:{version}",
                  f"{repository}:{platform_release}",
                  f"{repository}:sha-{short_sha}",
              ]
              cmd = [
                  "docker",
                  "buildx",
                  "build",
                  "--platform",
                  "linux/amd64",
                  "--push",
                  "--file",
                  dockerfile,
              ]
              for tag in tags:
                  cmd.extend(["--tag", tag])
              cmd.append(".")

              print(f"Publishing {app['name']} image with tags: {', '.join(tags)}")
              subprocess.run(cmd, check=True)
          PY

      - name: Publish changed Python packages
        if: steps.plan.outputs.has_python_packages == 'true'
        env:
          UV_PUBLISH_TOKEN: ${{ secrets.PYPI_API_TOKEN }}
        shell: bash
        run: |
          if [[ -z "${UV_PUBLISH_TOKEN:-}" ]]; then
            echo "PYPI_API_TOKEN is not configured; skipping Python publish."
            exit 0
          fi
          IFS=',' read -r -a pkgs <<< "${{ steps.plan.outputs.python_package_dirs }}"
          args=()
          for pkg in "${pkgs[@]}"; do
            [[ -z "$pkg" ]] && continue
            args+=(--package "$pkg")
          done
          ./scripts/publish-python-packages.sh --publish --index pypi "${args[@]}"

      - name: Publish changed TypeScript package
        if: steps.plan.outputs.has_typescript_packages == 'true'
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
        shell: bash
        run: |
          if [[ -z "${NPM_TOKEN:-}" ]]; then
            echo "NPM_TOKEN is not configured; skipping npm publish."
            exit 0
          fi
          echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > ~/.npmrc
          cd packages/mimic-sdk-ts
          npm publish --access public

      - name: Configure git identity for tags
        if: steps.plan.outputs.has_changes == 'true'
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Create and push immutable tags
        if: steps.plan.outputs.has_changes == 'true'
        shell: bash
        run: |
          ./scripts/release/tag-release.sh \
            --plan release/latest-release-plan.json \
            --manifest manifest.yaml \
            --push

      - name: Upload manifest artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-manifest-${{ github.sha }}
          path: |
            manifest.yaml
            release/latest-release-plan.json
            releases/CHANGELOG.md
